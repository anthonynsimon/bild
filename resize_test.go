package bild

import (
	"fmt"
	"image"
	"testing"
)

func TestResize(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "empty",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
			expected: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
		},
		{
			name:   "x1",
			width:  1,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
		},
		{
			name:   "x2",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only horizontal x2",
			width:  2,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 1),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only vertical x2",
			width:  1,
			height: 2,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "x0.5",
			width:  1,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
		},
		{
			name:   "only horizontal x0.5",
			width:  1,
			height: 2,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only vertical x0.5",
			width:  2,
			height: 1,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 1),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "x0",
			width:  0,
			height: 0,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
		},
	}

	for _, c := range cases {
		result := Resize(c.img, c.width, c.height, NearestNeighbor)
		if !rgbaImageEqual(result, c.expected) {
			t.Error(testFailMessage("Resize no filter "+c.name, c.expected, result))
		}

		result = Resize(c.img, c.width, c.height, Linear)
		if !rgbaImageEqual(result, c.expected) {
			t.Error(testFailMessage("Resize with filter "+c.name, c.expected, result))
		}
	}
}

func TestResizeNearestNeighbor(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, NearestNeighbor)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeNearestNeighbor "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func TestResizeBox(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, Box)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeNearestNeighbor "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func TestResizeLinear(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xA3, 0x31, 0x31, 0xF9, 0x41, 0xB3, 0x21, 0xEA,
					0x40, 0x21, 0xB3, 0xEA, 0x5B, 0x7A, 0x7A, 0xB0,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, Linear)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeLinear "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func formatImageString(img *image.RGBA) string {
	var result string
	for y := 0; y < img.Bounds().Max.Y; y++ {
		result += "\n"
		for x := 0; x < img.Bounds().Max.X; x++ {
			pos := y*img.Stride + x*4
			result += fmt.Sprintf("%#X, ", img.Pix[pos+0])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+1])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+2])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+3])
		}
	}
	result += "\n"
	return result
}
