package bild

import (
	"fmt"
	"image"
	"testing"
)

func TestResize(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "empty",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
			expected: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
		},
		{
			name:   "x1",
			width:  1,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
		},
		{
			name:   "x2",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only horizontal x2",
			width:  2,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 1),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only vertical x2",
			width:  1,
			height: 2,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "x0.5",
			width:  1,
			height: 1,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix:    []uint8{0xFF, 0xFF, 0xFF, 0xFF},
			},
		},
		{
			name:   "only horizontal x0.5",
			width:  1,
			height: 2,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "only vertical x0.5",
			width:  2,
			height: 1,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 1),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
		},
		{
			name:   "x0",
			width:  0,
			height: 0,
			img: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 2),
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			expected: &image.RGBA{
				Stride: 0,
				Rect:   image.Rect(0, 0, 0, 0),
				Pix:    []uint8{},
			},
		},
	}

	for _, c := range cases {
		result := Resize(c.img, c.width, c.height, NearestNeighbor)
		if !rgbaImageEqual(result, c.expected) {
			t.Error(testFailMessage("Resize no filter "+c.name, c.expected, result))
		}

		result = Resize(c.img, c.width, c.height, Linear)
		if !rgbaImageEqual(result, c.expected) {
			t.Error(testFailMessage("Resize with filter "+c.name, c.expected, result))
		}
	}
}

func TestResizeNearestNeighbor(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, NearestNeighbor)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeNearestNeighbor "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func TestResizeBox(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
					0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, Box)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeNearestNeighbor "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func TestResizeLinear(t *testing.T) {
	cases := []struct {
		name     string
		width    int
		height   int
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name:   "x2",
			width:  4,
			height: 4,
			img: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name:   "x0.5",
			width:  2,
			height: 2,
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(0, 0, 2, 2),
				Pix: []uint8{
					0xA3, 0x31, 0x31, 0xF9, 0x41, 0xB3, 0x21, 0xEA,
					0x40, 0x21, 0xB3, 0xEA, 0x5B, 0x7A, 0x7A, 0xB0,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Resize(c.img, c.width, c.height, Linear)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("ResizeLinear "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func TestCrop(t *testing.T) {
	cases := []struct {
		name     string
		rect     image.Rectangle
		img      *image.RGBA
		expected *image.RGBA
	}{
		{
			name: "center",
			rect: image.Rect(1, 1, 3, 3),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(1, 1, 3, 3),
				Pix: []uint8{
					0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7,
					0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8,
				},
			},
		},
		{
			name: "top left",
			rect: image.Rect(0, 0, 1, 1),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 1 * 4,
				Rect:   image.Rect(0, 0, 1, 1),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF,
				},
			},
		},
		{
			name: "no change",
			rect: image.Rect(0, 0, 4, 4),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name: "larger intersect",
			rect: image.Rect(-50, -50, 50, 50),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name: "horizontal only",
			rect: image.Rect(2, 0, 4, 4),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 2 * 4,
				Rect:   image.Rect(2, 0, 4, 4),
				Pix: []uint8{
					0x40, 0xBF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
					0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
		{
			name: "vertical only",
			rect: image.Rect(0, 2, 4, 4),
			img: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 0, 4, 4),
				Pix: []uint8{
					0xFF, 0x0, 0x0, 0xFF, 0xBF, 0x40, 0x0, 0xFF, 0x40, 0xBF, 0x0, 0xFF, 0x0, 0xFF, 0x0, 0xFF,
					0xBF, 0x0, 0x40, 0xFF, 0x97, 0x38, 0x38, 0xF7, 0x48, 0xA7, 0x28, 0xE7, 0x20, 0xDF, 0x20, 0xDF,
					0x40, 0x0, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x0, 0x0, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
			expected: &image.RGBA{
				Stride: 4 * 4,
				Rect:   image.Rect(0, 2, 4, 4),
				Pix: []uint8{
					0x40, 0x00, 0xBF, 0xFF, 0x48, 0x28, 0xA7, 0xE7, 0x58, 0x78, 0x78, 0xB8, 0x60, 0xA0, 0x60, 0xA0,
					0x00, 0x00, 0xFF, 0xFF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x60, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x80,
				},
			},
		},
	}

	for _, c := range cases {
		actual := Crop(c.img, c.rect)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("Crop "+c.name, formatImageString(c.expected), formatImageString(actual)))
		}
	}
}

func formatImageString(img *image.RGBA) string {
	var result string
	for y := 0; y < img.Bounds().Dy(); y++ {
		result += "\n"
		for x := 0; x < img.Bounds().Dx(); x++ {
			pos := y*img.Stride + x*4
			result += fmt.Sprintf("%#X, ", img.Pix[pos+0])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+1])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+2])
			result += fmt.Sprintf("%#X, ", img.Pix[pos+3])
		}
	}
	result += "\n"
	return result
}
