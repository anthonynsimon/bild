package imgio

import (
	"bytes"
	"image"
	"testing"
)

var encodeFormats = map[string]Format{
	"png":  PNG,
	"jpeg": JPEG,
	"jpg":  JPEG,
}

func TestEncode(t *testing.T) {
	cases := []struct {
		format Format
		value  image.Image
	}{
		{
			format: PNG,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
				},
			},
		},
		{
			format: JPEG,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x00, 0xFF,
					0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
				},
			},
		},
	}

	for _, c := range cases {
		buf := bytes.Buffer{}
		Encode(&buf, c.value, c.format)
		_, outFormat, err := image.Decode(&buf)
		if err != nil {
			t.Error(err)
		}
		if encodeFormats[outFormat] != c.format {
			t.Errorf("%s: expected: %#v, actual: %#v", "Encode", c.format, outFormat)
		}
	}
}
